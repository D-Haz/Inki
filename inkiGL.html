<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Inki Blot V0.3.2.3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #fff; }
        canvas { position: fixed; width: 100vw; height: 100vh;
            filter: blur(1px) contrast(150%); }
        #speed-slider { position: fixed; top: 10px; left: 10px; opacity: 0;}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <input id="speed-slider" type="range" min="0.001" max="0.1" step="0.001" value="0.01">
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
            vUv = 0.5 * (position + 1.0);
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D texture;
        uniform float uTime;
        uniform vec2 uResolution;
        uniform float cellSize;
        uniform float initialCells;
        uniform float mutationRate;
        uniform float fadeRate;
        
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        void main() {
            vec2 uv = vUv;
            uv.x = abs(uv.x - 0.5) + 0.5; // Mirror symmetry
            
            vec2 pixel = vec2(cellSize) / uResolution;
            vec3 acc = vec3(0.0);
            float count = 0.0;
            
            // Game of Life neighborhood sampling
            for(float x = -1.0; x <= 1.0; x++) {
                for(float y = -1.0; y <= 1.0; y++) {
                    vec2 offset = vec2(x, y) * pixel;
                    vec3 sample = texture2D(texture, uv + offset).rgb;
                    acc += sample;
                    count += step(0.1, length(sample));
                }
            }
            
            // Game of Life rules
            vec3 current = texture2D(texture, uv).rgb;
            float alive = step(0.1, length(current));
            float neighbors = count - alive;
            float nextAlive = (neighbors == 3.0) || (alive == 1.0 && neighbors == 2.0) ? 1.0 : 0.0;
            
            // Mutation and fading
            float mutation = step(1.0 - mutationRate, random(uv + uTime));
            nextAlive = max(nextAlive, mutation);
            vec3 color = mix(current * fadeRate, vec3(1.0), nextAlive);
            
            // Initial seed
            float seed = step(1.0 - initialCells, random(uv));
            color = mix(color, vec3(1.0), seed * step(uTime, 1.0));
            
            // Color blending
            vec3 bleed = acc / 9.0; // Adjusted for ink effect
            gl_FragColor = vec4(mix(color, bleed, 0.5), 1.0);
        }
    </script>
    <script>
        const config = {
            cellSize: 3.5,
            initialCells: 0.000000005,
            mutationRate: 0.0003,
            fadeRate: 0.93
        };
        
        let gl, program, buffers, frameBuffer, textures = [];
        let speed = 0.000000000003;
        
        function initGL() {
            const canvas = document.querySelector('canvas');
            gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
            if (!gl) {
                alert('WebGL not supported');
                return;
            }
            
            resizeCanvas();
            
            program = gl.createProgram();
            const vertexShader = compileShader(gl.VERTEX_SHADER, document.getElementById('vertexShader').text);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fragmentShader').text);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            buffers = createBuffer();
            frameBuffer = gl.createFramebuffer();
            textures = [createTexture(), createTexture()];
            
            // Initialize uniforms
            gl.useProgram(program);
            gl.uniform1f(gl.getUniformLocation(program, 'cellSize'), config.cellSize);
            gl.uniform1f(gl.getUniformLocation(program, 'initialCells'), config.initialCells);
            gl.uniform1f(gl.getUniformLocation(program, 'mutationRate'), config.mutationRate);
            gl.uniform1f(gl.getUniformLocation(program, 'fadeRate'), config.fadeRate);
            
            // Initialize speed slider
            const speedSlider = document.getElementById('speed-slider');
            speedSlider.value = speed;
            speedSlider.oninput = () => {
                speed = parseFloat(speedSlider.value);
            };
        }
        
        function createBuffer() {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
            return buffer;
        }
        
        function createTexture() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            return texture;
        }
        
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        
        function resizeCanvas() {
            const canvas = gl.canvas;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        function render(time) {
            gl.useProgram(program);
            
            // Update uniforms
            gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time * speed);
            gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), gl.canvas.width, gl.canvas.height);
            
            // Set up vertex buffer
            const positionLocation = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Ping-pong between textures
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[1], 0);
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Swap textures
            textures.reverse();
            
            // Render to screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            textures.forEach(texture => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width, gl.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            });
        });
        
        initGL();
        requestAnimationFrame(render);
    </script>
</body>
</html>
